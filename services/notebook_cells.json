{ "cells": [ { "cell_type": "markdown", "metadata": { "language": "markdown" }, "source": [ "# Interactive Sales Data Generator (Observable)", "", "Generate, visualize, analyze and export synthetic monthly sales data.", "", "Features:", "- Seeded RNG (reproducible)", "- Presets and parameter controls", "- Plot-based time-series visualization with moving averages", "- Category filtering and time-window selection", "- CSV and PNG export", "- Trend analysis (linear trend + R²)", "", "Run cells in order and share the notebook link with teammates." ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "import Plot from "@observablehq/plot";", "import { Inputs } from "@observablehq/inputs";", "import * as d3 from "https://cdn.skypack.dev/d3@7\";", "import seedrandom from "https://cdn.skypack.dev/seedrandom\";", "import { html } from "htl";" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Generator: returns array of {date, sales, category, index, _date}", "function generateMonthlySalesData(opts = {}) {", " const {", " count = 24,", " startDate = '2024-01-01T00:00:00Z',", " baseValue = 9000,", " trendPerMonth = 2500,", " seasonalityAmplitude = 3600,", " seasonalityPeriod = 12,", " noiseAmount = 800,", " categories = ['fixtures', 'furniture', 'appliances'],", " rng = Math.random,", " } = opts;", "", " const numPoints = Math.max(0, Math.trunc(count || 0));", " const start = typeof startDate === 'string' ? new Date(startDate) : new Date(startDate);", " if (isNaN(start.getTime())) throw new Error('Invalid start date');", "", " const data = [];", " for (let i = 0; i < numPoints; i++) {", " const currentDate = new Date(start);", " currentDate.setUTCMonth(currentDate.getUTCMonth() + i);", "", " const trendValue = trendPerMonth * i;", " const seasonalityValue = seasonalityAmplitude * Math.sin((2 * Math.PI * i) / seasonalityPeriod);", " const noiseValue = (rng() - 0.5) * 2 * noiseAmount;", "", " const sales = baseValue + trendValue + seasonalityValue + noiseValue;", " const category = categories[Math.floor(rng() * categories.length)];", "", " data.push({", " date: currentDate.toISOString().slice(0, 10),", " sales: Math.max(0, Math.round(sales)),", " category,", " index: i,", " _date: new Date(currentDate)", " });", " }", " return data;", "}" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Presets", "presets = {", " default: { count:24, baseValue:9000, trendPerMonth:2500, seasonalityPeriod:12, seasonalityAmplitude:3600, noiseAmount:800, seed:42 },", " highSeasonality: { count:24, baseValue:10000, trendPerMonth:1000, seasonalityPeriod:12, seasonalityAmplitude:8000, noiseAmount:500, seed:42 },", " strongTrend: { count:24, baseValue:5000, trendPerMonth:4000, seasonalityPeriod:12, seasonalityAmplitude:2000, noiseAmount:500, seed:42 },", " highVolatility: { count:24, baseValue:10000, trendPerMonth:1500, seasonalityPeriod:6, seasonalityAmplitude:4000, noiseAmount:2000, seed:42 },", " stable: { count:24, baseValue:10000, trendPerMonth:500, seasonalityPeriod:12, seasonalityAmplitude:1000, noiseAmount:300, seed:42 },", " quarterly: { count:24, baseValue:8000, trendPerMonth:1000, seasonalityPeriod:3, seasonalityAmplitude:3000, noiseAmount:600, seed:42 }", "};" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Preset selector", "viewof preset = Inputs.select(Object.keys(presets), { label: "Preset", value: "default" })" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "viewof count = Inputs.range({label: "Months", min: 1, max: 60, step: 1, value: 24})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "viewof baseValue = Inputs.range({label: "Base Value", min: 0, max: 20000, step: 500, value: 9000})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "viewof trendPerMonth = Inputs.range({label: "Trend per Month", min: -5000, max: 5000, step: 100, value: 2500})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "viewof seasonalityPeriod = Inputs.range({label: "Seasonality Period (months)", min: 3, max: 24, step: 1, value: 12})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "viewof seasonalityAmplitude = Inputs.range({label: "Seasonality Amplitude", min: 0, max: 10000, step: 100, value: 3600})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "viewof noiseAmount = Inputs.range({label: "Noise Amount", min: 0, max: 5000, step: 50, value: 800})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "viewof seed = Inputs.number({label: "Seed", min: 1, max: 99999, step: 1, value: 42})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Effective options: merge selected preset with slider values", "options = ({ ...presets[preset],", " count,", " baseValue,", " trendPerMonth,", " seasonalityPeriod,", " seasonalityAmplitude,", " noiseAmount,", " seed", "})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "data = (() => {", " const rng = seedrandom(String(options.seed));", " const raw = generateMonthlySalesData({ ...options, rng });", " raw.forEach(d => d._date = new Date(d.date));", " return raw;", "})()" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Visualization controls: time window and MA; category multi-select derived from data", "viewof timeWindow = Inputs.select(['1m','3m','6m','12m','24m','all'], {label: 'Time window', value: 'all'})", "", "viewof maWindow = Inputs.range({label: 'Moving average (months)', min:1, max:12, value:3, step:1})", "", "viewof categories = Inputs.multiselect(Array.from(new Set(data.map(d => d.category))), {label:'Categories', value: Array.from(new Set(data.map(d => d.category)))})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Filter data and compute moving averages", "filteredData = (() => {", " const selected = new Set(categories);", " const timeWindowMonths = timeWindow === 'all' ? Infinity : parseInt(timeWindow);", " const now = new Date(Math.max(...data.map(d => d._date)));", " const minDate = new Date(now);", " if (timeWindowMonths !== Infinity) minDate.setMonth(minDate.getMonth() - timeWindowMonths);", "", " const fd = data.filter(d => selected.has(d.category) && (timeWindowMonths === Infinity || d._date >= minDate));", " return fd;", "})();", "", "movingAverages = (() => {", " const window = maWindow;", " if (!window || window <= 1) return [];", " const cats = Array.from(new Set(filteredData.map(d => d.category)));", " return cats.flatMap(cat => {", " const pts = filteredData.filter(d => d.category === cat).sort((a,b) => a._date - b._date);", " const half = Math.floor(window/2);", " return pts.map((p,i) => {", " const s = Math.max(0, i-half);", " const e = Math.min(pts.length, i+half+1);", " const windowPts = pts.slice(s,e);", " const avg = d3.mean(windowPts, d => d.sales);", " return avg == null ? null : { date: p.date, _date: p._date, sales: avg, category: cat, isMA: true };", " }).filter(Boolean);", " });", "})();" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Plot cell — assign to plot so export can reference it", "plot = Plot.plot({", " height: 480,", " marginLeft: 70,", " x: { label: 'Date', tickFormat: d => d.toISOString().slice(0,10), grid: true },", " y: { label: 'Sales ($)', grid: true },", " marks: [", " Plot.line(filteredData, { x: '_date', y: 'sales', stroke: 'category', strokeWidth: 1.5, sort: true }),", " Plot.dot(filteredData, { x: '_date', y: 'sales', fill: 'category', r: 3 }),", " Plot.line(movingAverages, { x: '_date', y: 'sales', stroke: 'category', strokeWidth: 2, strokeDasharray: '4,4', sort: true })", " ],", " color: { legend: true, scheme: 'tableau10' }", "})" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Export helpers (use plot variable for SVG)", "function dataToCSV(data) {", " const headers = ['date','category','sales'];", " return [headers.join(','), ...data.map(r => [r.date, r.category, r.sales].join(','))].join('\n');", "}", "", "async function exportPlotPng(filename = 'sales-chart.png', width = 900, height = 480, scale = 2) {", " const svg = plot; // plot is the SVG node returned above", " if (!svg || !(svg instanceof SVGElement)) throw new Error('Plot SVG not found');", " const canvas = document.createElement('canvas');", " canvas.width = width * scale; canvas.height = height * scale;", " const ctx = canvas.getContext('2d'); ctx.scale(scale, scale);", " const svgString = new XMLSerializer().serializeToString(svg);", " const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });", " const url = URL.createObjectURL(blob);", " await new Promise((resolve, reject) => {", " const img = new Image();", " img.onload = () => { ctx.fillStyle = 'white'; ctx.fillRect(0,0,width,height); ctx.drawImage(img,0,0,width,height); URL.revokeObjectURL(url); resolve(); };", " img.onerror = reject; img.src = url;", " });", " const png = canvas.toDataURL('image/png');", " const a = document.createElement('a'); a.href = png; a.download = filename; a.click();", "}", "", "function exportDataCsv(data, filename = 'sales_data.csv') {", " const csv = dataToCSV(data);", " const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });", " const url = URL.createObjectURL(blob);", " const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);", "}" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Export buttons using html template", "viewof exports = html<div style=\"display:flex; gap:8px; margin:0.5em 0;\">",         "  <button style=\"padding:6px 10px;\" onclick=${async () => { await exportPlotPng(); }}>Export Chart PNG</button>",         "  <button style=\"padding:6px 10px;\" onclick=${() => exportDataCsv(filteredData)}>Export CSV</button>",         "</div>" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Sync preset helper: sets viewof controls when preset is changed", "// This updates the visible sliders to match the preset", "syncPreset = (() => {", " try {", " const p = presets[preset];", " if (!p) return 'No preset';", " if (typeof viewof count !== 'undefined') { viewof count.value = p.count; viewof count.dispatchEvent(new Event('input', { bubbles: true })); }", " if (typeof viewof baseValue !== 'undefined') { viewof baseValue.value = p.baseValue; viewof baseValue.dispatchEvent(new Event('input', { bubbles: true })); }", " if (typeof viewof trendPerMonth !== 'undefined') { viewof trendPerMonth.value = p.trendPerMonth; viewof trendPerMonth.dispatchEvent(new Event('input', { bubbles: true })); }", " if (typeof viewof seasonalityPeriod !== 'undefined') { viewof seasonalityPeriod.value = p.seasonalityPeriod; viewof seasonalityPeriod.dispatchEvent(new Event('input', { bubbles: true })); }", " if (typeof viewof seasonalityAmplitude !== 'undefined') { viewof seasonalityAmplitude.value = p.seasonalityAmplitude; viewof seasonalityAmplitude.dispatchEvent(new Event('input', { bubbles: true })); }", " if (typeof viewof noiseAmount !== 'undefined') { viewof noiseAmount.value = p.noiseAmount; viewof noiseAmount.dispatchEvent(new Event('input', { bubbles: true })); }", " if (typeof viewof seed !== 'undefined') { viewof seed.value = p.seed; viewof seed.dispatchEvent(new Event('input', { bubbles: true })); }", " } catch (e) { console.warn('syncPreset error', e); }", " return synced ${preset};", "})()" ] }, { "cell_type": "code", "metadata": { "language": "javascript" }, "source": [ "// Trend analysis: slopes and r2 per category", "analysis = (() => {", " const byCat = d3.group(filteredData, d => d.category);", " const out = {};", " for (const [cat, pts] of byCat) {", " const s = pts.slice().sort((a,b) => a._date - b._date);", " if (s.length < 2) { out[cat] = null; continue; }", " const x = s.map((_,i) => i);", " const y = s.map(d=>d.sales);", " const n = x.length;", " const sx = d3.sum(x); const sy = d3.sum(y);", " const sxy = d3.sum(x.map((xi,i)=>xiy[i]));", " const sx2 = d3.sum(x.map(xi=>xixi));", " const slope = (nsxy - sxsy) / (nsx2 - sxsx);", " const intercept = (sy - slopesx)/n;", " const pred = x.map(xi => slopexi + intercept);", " const ssRes = d3.sum(y.map((yi,i)=> (yi - pred[i])**2));", " const ssTot = d3.sum(y.map(yi => (yi - d3.mean(y))**2));", " const r2 = 1 - ssRes/ssTot;", " out[cat] = { slope, intercept, r2 };", " }", " return out;", "})()" ] }, { "cell_type": "markdown", "metadata": { "language": "markdown" }, "source": [ "## Sharing & next steps", "", "- To share: create a new Observable notebook and paste cells in order. Save and share the notebook URL with your teammates.", "- I can export this as a single downloadable .ipynb-like JSON if you want a file to attach to issues or PRs.", "- Next improvements: annotated events, export size options, or a packaged npm module for embedding." ] } ] }](https://microsoft.com)))